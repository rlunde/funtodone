
I'm switching over to a "standard" linux based install (not using Heroku or
a shared hosting server) -- I signed up for Digital Ocean and mapped the funtodone.com
domain to it (although I haven't installed it yet, so don't bother trying it).

I want to take a big step back and set up this github project as a "standard" golang-based
web project on github, which will require some investigation.

Here are some links for learning how to get set up on Digital Ocean:
https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-14-04
https://www.digitalocean.com/community/tutorials/how-to-configure-nginx-as-a-web-server-and-reverse-proxy-for-apache-on-one-ubuntu-14-04-droplet

Here are some resources for a "standard" golang project:

https://golang.org/doc/code.html
https://talks.golang.org/2014/organizeio.slide#1
https://github.com/golang/go/wiki/GithubCodeLayout

I found out (finally) that the way most people develop go projects in github is that they make
a symlink from github.com/<theirname>/<project> to their real source directory, or vice versa,
since otherwise you're kind of stuck.

The other thing I'm struggling with is the choice of whether to use the standard "everything
including 6,234 different kitchen sinks" basic template for a react/redux template, with megabytes
of node_modules for a "hello world" type app, or be ornery and insist on doing writing things
that will actually be deployed to the browser, with the exception of things pulled in from a
CDN (e.g. react, redux, and babel).

I'm leaning towards the latter, since I think simplicity is worth fighting for.

I don't want to turn this into a project management thing, but I do want to (eventually) keep
track of all the things that people actually want to keep track of. So for example, if you
want to say that one task can't be started before another is done (or partly done), it
should let you do that.

Also, a "stack" should be as close to an actual stack as you can make it, so you're only
thinking about one thing at a time (one level at a time), but there are situations where
things are interrelated to the point where that's impractical. So for a data model for
the stack, I want to have each task have a parent and children and a "height". It should
make it hard to see and expand tasks that aren't on the top of the stack, but if you've
already done that it should keep all the data (perhaps you expanded one task and then
realized that you had to do another first).

All this needs example to make it understandable!

I plan to start off with a library, then wrap that in a CLI, then once the CLI is
working, add a very simple web UI that just does basic stuff, and then finally try to
make a nice responsive web SPA and/or mobile-web app. Just like separation of concerns,
if I focus on one kind of capability at a time, starting with what makes this interesting,
by the time I get to implementing OAuth (or whatever), it will actually be worth it.

I've got a first cut at a data structure for the tasks as least (I'm sure it will evolve)
but now I need to figure out persistence. Ideally the in-memory representation can continue
to use pointers, but the persistence layer needs to convert that to IDs and database records,
and I need to figure out a data store. Since it's really just a pile of tasks, hooked together
in various ways, a JSON data store is fine. I guess I should look into the current state of
such things -- could be that there's a free (or cheap) data store already out there hosting
such things. If not, I can always run Mongo or any of the others on my own VM, but that's
not going to scale if people start to use it.

I think I'll try using Firebase, although I'm confused about it so far. The web app puts
what appears to be credentials right in the index.html page, so what's to stop someone
from grabbing that and using it themselves? I think I may need to do a bunch of reading
about it:

https://console.firebase.google.com/project/funtodone/overview
https://firebase.google.com/docs/admin/setup
https://firebase.google.com/docs/database/rest/start
https://firebase.google.com/docs/web/setup
https://github.com/firebase/quickstart-js/tree/master/database
https://firebase.google.com/docs/reference/js/
https://firebase.google.com/docs/samples/#web
https://github.com/zabawaba99/firego

I think what might work is to just use the REST API from the Go side, and not directly
expose any of the firebase web stuff on the client. It might be possible to do client auth
via firebase on the client side, and pass that to the Go server? At this point I feel
like I don't even have the right language to ask the right questions.

Alternatively, I could move all the Task data from Go to javascript, and do everything
on the client side, which might be the most direct way to support synchronized web, iOS,
and Android apps. I think I'll avoid that for now, if I can, since I may never get around
to doing native apps.

Also, it just makes me nervous to have the client talk directly to the database.

There's a tutorial here that looks like a good starting point:
https://www.tutorialspoint.com/firebase/firebase_data.htm

After reading about it for an hour or so, I'm nervous that I'm going down another rabbit
hole. The built-in auth looks great, so maybe I could use that by itself, and just use
the UserID returned to the web page as the key (initially) in my own data store. I guess
I could use the combination of an account name and the UserID, to minimize the chance that
somebody was faking a UserID (there may be a REST API to validate things as well).

I think maybe CouchDB or MongoDB would be a good choice for a simple, light-weight JSON
database.

I installed MongoDB. When brew finished installing it, it said to use:
  brew services start mongodb
Or, if you don't want/need a background service you can just run:
  mongod --config /usr/local/etc/mongod.conf

It's putting the data in /usr/local/var/mongodb by default.

The getting started guides are here: https://docs.mongodb.com/master/#getting-started
The closest thing to go of those guides is probably the python version:
https://docs.mongodb.com/getting-started/python/

There is a go library for mongo here: https://labix.org/mgo

I think the main thing to do is change the data model to include a mongo ID, in
addition to the pointers. Maybe make a struct that is a "lazy pointer" that contains
either the pointer to a task (children, siblings, or a parent) or a mongo ID, or
both. When writing, fill in the IDs. When reading from the database, fill in the
pointers. When creating tasks in memory, only use pointers.

Follow up on that: the mgo package (by default) wants to do a single struct at a
time, so the mongo ID and the pointer have to be at the top level of a struct, not
in an embedded (or referenced) struct. So the "lazy pointer" idea won't work unless
I want to really dig into how mgo works and do things at a much lower level -- and
I don't think it's worth it. For one thing, I don't like the idea of tying things
too closely to MongoDB -- it'd be nice to make it easy to switch to Cassandra (or
whatever).

It turns out that every struct that is written to Mongo needs to have an _id element,
which Mongo will make if you don't make it yourself, so I couldn't have a "lazy pointer"
struct on its own, I had to make it a part of the Task structure.

I think I would like to make my own mgo tutorial as part of this, since the material
that exists is very sketchy. Maybe I should start with Mongo rather than D3 (or in
addition to D3) with Goodwin?

A note on my "flashtasks" idea under "ideas":

I spent several weeks working with that, and just couldn't get myself to stick to it.
I'd find myself continuing to work on something rather than stopping after 7 minutes, or
not starting anything and working on something not even on my list, etc. Not just a few
times, but over and over. I came to believe that if all the mechanisms for choosing tasks,
tracking time, etc. were built into this tool, it still wouldn't make enough of a difference.

It's just unnatural to divide things up into chunks of 7 minutes (or similar). Things aren't
"discrete" like that -- they don't break down into nice bits. I still think the FunToDone
projects are going to work great, just that things have more natural sizes -- sometimes too
large to be done all in one sitting, and sometimes so small that it's hard to see the value
in calling it out separately.

Note on making things "fun":

 1. Feedback makes things fun -- not badges and levels, but just simple things like
    small animations, humorous congratulations, and unusual animations in progress meters.
 2. Inspiration is good. There should be inspirational quotes, as well as small stories
    that people can read that make them feel good about doing things.
 3. Set micro-deadlines with timers that count down.
 4. Keep a score, and count things like splitting a task, adding a level, getting a task
    done, etc. Give people a stretch goal, and keep track of progress over time.

Actually, the main things that make things fun are:
 1. actually getting things done -- hence the drive to divide things up into smaller pieces
 2. seeing how much you've got done -- hence keeping graphs, charts, etc. (and making them interesting)
 3. getting recognition for getting things done -- have to think how to do this.
   a) competition vs collaboration vs communication
   b) see if I can find out what kind of recognition works best, and who it helps the most

I briefly looked into BDD type testing, and it looks like there is some good stuff in ginkgo,
but I don't have time to do that right now. Later on, look at ginkgo with gomega (https://onsi.github.io/ginkgo/)

I've been adding authboss stuff into the service, but I'm having second thoughts
as usual. It's too complicated, too undocumented, and too likely to break when they
release their refactored "v2" release (see their website).

There's a JWT example middleware for Gin as well, which may fit in somehow -- I'd
love to figure out how and where to use JWT.

I'm very discouraged about this. I want a step by step guide for how to add
authentication to a Gin-based web service with a JS/React front-end, or at least
something that's close enough that I can figure it out without spending some
enormous number of hours. That's not happening.

Maybe what I need to do is back up and make a sample project with a code generator
that makes exactly the sort of sample project that I want?

It should be a command line app that asks questions and saves a config file. It should
generate something that works with either Gin or Gorilla (or negroni?), with a front-end
sample that works with either react or vue.

How would I even approach a project like that? Maybe make it a part of goodwin?

There's a command line app and sample go web service named bluejay that looks close
to what I want, except that it uses mysql rather than mongo (although the guy who
made it made another project with mongo as an option). Maybe the easier thing to
do would be to start off with that, and migrate to mongo and Gin?

https://blue-jay.github.io/
https://github.com/blue-jay/blueprint
